{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Buildantic: A library for JSON schema generation and data validation, with native support for LLM function-calling formats.","text":"<p>Buildantic streamlines the process of generating schemas from types and OpenAPI specification operations, as well as validating data against these schemas.</p> <p>Beyond standard JSON Schema generation, It facilitates the creation of schema formats tailored for Large Language Model (LLM) function calling. The supported formats include <code>OpenAI</code> (compatible with most function-calling LLMs), <code>Anthropic</code>, and <code>Gemini</code>.</p> <ul> <li>Type support</li> <li>OpenAPI specification support</li> </ul> <p><code>Buildantic</code> is highly inspired from the talk \"Pydantic is all you need\" by Jason Liu, author of Instructor library.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<pre><code>pip install -U buildantic\n</code></pre>"},{"location":"#working-with-types","title":"Working with types","text":"About <code>TypeDescriptor</code> <p><code>TypeDescriptor</code> utilizes pydantic's <code>TypeAdapter</code> internally. The schema generated by the adapter is updated with docstring recursively. Any type supported by pydantic will work with this descriptor.</p> <p>Update type schema</p> Source code in <code>buildantic/utils.py</code> <pre><code>def update_schema(__type: type, schema: t.Dict[str, t.Any]) -&gt; t.Dict[str, t.Any]:\n    \"\"\"Update type schema\"\"\"\n    if \"anyOf\" in schema:\n        of_key = \"anyOf\"\n    elif \"oneOf\" in schema:\n        of_key = \"oneOf\"\n    else:\n        of_key = None\n\n    origin, arg_types = t.get_origin(__type) or __type, t.get_args(__type)\n    if of_key is not None:\n        schema[of_key] = [update_schema(tp, sc) for tp, sc in zip(arg_types, schema[of_key])]\n    elif schema.get(\"type\") == \"object\" and \"properties\" in schema:\n        if not schema.get(\"additionalProperties\", True):\n            _ = schema.pop(\"additionalProperties\")\n        schema = update_object_schema(origin, schema=schema)\n    elif schema.get(\"type\") == \"array\":\n        schema = update_array_schema(arg_types[0] if arg_types else origin, schema=schema)\n\n    return schema\n</code></pre>"},{"location":"#descripting-a-simple-type","title":"Descripting a simple type","text":"<pre><code>import typing as t\n\nfrom buildantic import TypeDescriptor\n\ndescriptor = TypeDescriptor(t.List[str])\n</code></pre> <ul> <li>Get standard JsON schema</li> </ul> <pre><code>print(descriptor.schema)\n\"\"\"{'items': {'type': 'string'}, 'type': 'array'}\"\"\"\n</code></pre> <ul> <li>Get function calling schema</li> </ul> <p>As function-calling only accepts object input, the simple type is transformed into object type with <code>input</code> being the only property key.</p> <pre><code>print(descriptor.openai_schema)\n\"\"\"\n{\n    'name': 'List',\n    'parameters': {\n        'type': 'object',\n        'properties': {\n            'input': {\n                'items': {'type': 'string'}, 'type': 'array'\n            }\n        }\n    }\n}\n\"\"\"\n</code></pre> <ul> <li>Validating a python object</li> </ul> <pre><code>print(descriptor.validate_python([\"name\", \"age\"]))\n# OR output generated from function-calling schema\nprint(descriptor.validate_python({\"input\": [\"name\", \"age\"]}))\n\"\"\"['name', 'age']\"\"\"\n</code></pre> <ul> <li>Validating a JsON object</li> </ul> <pre><code>print(descriptor.validate_json('[\"name\", \"age\"]'))\n# OR output generated from function-calling schema\nprint(descriptor.validate_json('{\"input\": [\"name\", \"age\"]}'))\n\"\"\"['name', 'age']\"\"\"\n</code></pre>"},{"location":"#descripting-a-simple-type-with-custom-name-and-description","title":"Descripting a simple type with custom name and description","text":"<p>Annonate the simple type (non-object type) with pydantic's <code>FieldInfo</code> to add name and description</p> <pre><code>import typing as t\n\nfrom buildantic import TypeDescriptor\nfrom pydantic.fields import Field\n\ndescriptor = TypeDescriptor[t.List[str]](\n    t.Annotated[t.List[str], Field(alias=\"strings\", description=\"List of string\")]\n)\nprint(descriptor.schema)\n\"\"\"{'items': {'type': 'string'}, 'type': 'array'}\"\"\"\n\nprint(descriptor.openai_schema)\n\"\"\"\n{\n    \"name\": \"strings\",\n    \"description\": \"List of string\",\n    \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"input\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}}\n        },\n        \"required\": [\"input\"]\n    }\n}\n\"\"\"\n\nprint(descriptor.validate_python([\"name\", \"age\"]))\n\"\"\"['name', 'age']\"\"\"\n\nprint(descriptor.validate_json('{\"input\": [\"name\", \"age\"]}'))\n\"\"\"['name', 'age']\"\"\"\n</code></pre>"},{"location":"#descripting-an-object-type","title":"Descripting an object type","text":"<p>An object type refers to type with properties. <code>TypedDict</code>, pydantic model, dataclasses and functions are some examples of it.</p> <p><code>TypeDescriptor</code> aliased as <code>descript</code> can be used as a decorator.</p> <pre><code>from buildantic import descript\nfrom typing import Any, Dict, Literal, Tuple\n\n@descript # same as TypeDescriptor(create_user)\nasync def create_user(\n    name: str, age: int, role: Literal[\"developer\", \"tester\"] = \"tester\"\n) -&gt; Tuple[bool, Dict[str, Any]]:\n    \"\"\"\n    Create a new user\n\n    :param name: Name of the user\n    :param age: Age of the user\n    :param role: Role to assign.\n    \"\"\"\n    return (True, {\"metadata\": [name, age, role]})\n\nprint(create_user.gemini_schema)\n\"\"\"\n{\n    \"name\": \"create_user\",\n    \"description\": \"Create a new user\",\n    \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"name\": {\n                \"type\": \"string\", \"description\": \"Name of the user\"\n            },\n            \"age\": {\n                \"type\": \"integer\", \"description\": \"Age of the user\"\n            },\n            \"role\": {\n                \"type\": \"string\",\n                \"description\": \"Role to assign.\",\n                \"enum\": [\"developer\", \"tester\"],\n                \"format\": \"enum\"\n            }\n        },\n        \"required\": [\"name\", \"age\"]\n    }\n}\n\"\"\"\n\nimport asyncio\n\nprint(asyncio.run(create_user.validate_python({\n    \"name\": \"synacktra\", \"age\": 21, \"role\": \"developer\"\n})))\n\"\"\"(True, {'metadata': ['synacktra', 21, 'developer']})\"\"\"\n</code></pre> Validation methods shows correct return type <p></p>"},{"location":"#creating-a-registry-of-type-descriptors","title":"Creating a registry of type descriptors","text":"<pre><code>from typing import Tuple, Literal\n\nfrom pydantic import BaseModel\nfrom buildantic import Registry\n\nregistry = Registry()\n\n@registry.register\nclass UserInfo(BaseModel):\n    \"\"\"\n    User Information\n\n    :param name: Name of the user\n    :param age: Age of the user\n    :param role: Role to assign.\n    \"\"\"\n    name: str\n    age: int\n    role: Literal[\"developer\", \"tester\"] = \"tester\"\n\n\n@registry.register\ndef get_coordinates(location: str) -&gt; Tuple[float, float]:\n    \"\"\"Get coordinates of a location.\"\"\"\n    return (48.858370, 2.2944813)\n</code></pre> <ul> <li>Getting schema list in different formats</li> </ul> <pre><code>print(registry.schema)\nprint(registry.openai_schema)\nprint(registry.anthropic_schema)\nprint(registry.gemini_schema)\n</code></pre> <ul> <li>Validating a python object</li> </ul> <pre><code>print(registry.validate_python(id=\"UserInfo\", obj={\"name\": \"synacktra\", \"age\": 21}))\n\"\"\"name='synacktra' age=21 role='tester'\"\"\"\nprint(registry.validate_python(id=\"get_coordinates\", obj={\"location\": \"eiffeltower\"}))\n\"\"\"(48.85837, 2.2944813)\"\"\"\n</code></pre> <ul> <li>Validating a JsON object</li> </ul> <pre><code>print(registry.validate_json(id=\"UserInfo\", data='{\"name\": \"synacktra\", \"age\": 21}'))\n\"\"\"name='synacktra' age=21 role='tester'\"\"\"\nprint(registry.validate_json(id=\"get_coordinates\", data='{\"location\": \"eiffeltower\"}'))\n\"\"\"(48.85837, 2.2944813)\"\"\"\n</code></pre> <ul> <li>Accessing descriptor from registry instance</li> </ul> <pre><code>get_coords_descriptor = registry[\"get_coordinates\"]\n</code></pre>"},{"location":"#working-with-openapi-specification","title":"Working with OpenAPI Specification","text":"About OpenAPI operations <p>OpenAPI operations are loaded as operation descriptors in the <code>OpenAPIRegistry</code>.</p> <p>Validation methods returns a <code>RequestModel</code>, after which you can use your favorite http client library to finally make request to the API.</p> <pre><code>class RequestModel(BaseModel):\n    \"\"\"\n    Request Model returned by `OperationDescriptor` after validation.\n\n    :param path: Formatted and encoded path.\n    :param queries: Raw query mapping.\n    :param encoded_query: Formatted and encoded query.\n    :param headers: Raw header mapping.\n    :param cookies: Raw cookie mapping.\n    :param body: Raw body mapping.\n    \"\"\"\n    path: str\n    method: Method\n    queries: t.Dict[str, t.Any] | None = None\n    encoded_query: str | None = None\n    headers: t.Dict[str, t.Any] | None = None\n    cookies: t.Dict[str, t.Any] | None = None\n    body: t.Dict[str, t.Any] | None = None\n\n    @property\n    def path_with_query(self) -&gt; str:\n        \"\"\"Return path with query\"\"\"\n        if not self.encoded_query:\n            return self.path\n        return f\"{self.path}?{self.encoded_query}\"\n</code></pre> <ul> <li>Loading the specification as a registyr</li> </ul> <pre><code>from buildantic.registry import OpenAPIRegistry\nopenapi_registry = OpenAPIRegistry.from_file(\"/path/to/petstore-v3.json_or_yml\")\n# or\nopenapi_registry = OpenAPIRegistry.from_url(\n    \"https://raw.githubusercontent.com/OAI/OpenAPI-Specification/refs/heads/main/examples/v3.0/petstore.json\"\n)\n</code></pre> <ul> <li>Get list of operations</li> </ul> <pre><code>print(openapi_registry.ids)\n\"\"\"['listPets', 'createPets', 'showPetById']\"\"\"\n</code></pre> <ul> <li>Accessing specific operation descriptor from registry</li> </ul> <pre><code>print(openapi_registry[\"listPets\"].schema)\n\"\"\"\n{\n    'type': 'object',\n    'description': 'List all pets',\n    'properties': {\n        'limit': {\n            'type': 'integer',\n            'maximum': 100,\n            'format': 'int32',\n            'description': 'How many items to return at one time (max 100)'\n        }\n    }\n}\n\"\"\"\n\nprint(openapi_registry[\"createPets\"].schema)\n{\n    'type': 'object',\n    'description': 'Create a pet',\n    'properties': {\n        'requestBody': {\n            'type': 'object',\n            'properties': {\n                'id': {'type': 'integer', 'format': 'int64'},\n                'name': {'type': 'string'},\n                'tag': {'type': 'string'}\n            }\n        }\n    },\n    'required': ['requestBody']\n}\n</code></pre> <ul> <li>Getting schema list in different formats</li> </ul> <pre><code>print(registry.schema)\nprint(registry.openai_schema)\nprint(registry.anthropic_schema)\nprint(registry.gemini_schema)\n</code></pre> <ul> <li>Validating a python object</li> </ul> <pre><code>print(openapi_registry.validate_python(id=\"listPets\", obj={\"limit\": 99}))\n\"\"\"\npath='/pets' method='get' queries={'limit': 99} encoded_query='limit=99' headers=None cookies=None body=None\n\"\"\"\nprint(openapi_registry.validate_python(id=\"listPets\", obj={\"limit\": 101}))\n# This will raise `jsonschema.exceptions.ValidationError` exception\n</code></pre> <ul> <li>Validating a JsON object</li> </ul> <pre><code>print(openapi_registry.validate_json(\n    id=\"createPets\",\n    data='{\"requestBody\": {\"id\": 12, \"name\": \"rocky\", \"tag\": \"dog\"}}'\n))\n\"\"\"\npath='/pets' method='post' queries=None encoded_query=None headers=None cookies=None body={'id': 12, 'name': 'rocky', 'tag': 'dog'}\n\"\"\"\n</code></pre>"}]}